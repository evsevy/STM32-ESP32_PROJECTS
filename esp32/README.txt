///////////////////////////////////////////////////////////////////////////
//      _____ __     __ _   _           _____   ____   ______  _______   //
//     / ____|\ \   / /| \ | |         / ____| / __ \ |  ____||__   __|  //
//    | (___   \ \_/ / |  \| | ______ | (___  | |  | || |__      | |     //
//     \___ \   \   /  | . ` ||______| \___ \ | |  | ||  __|     | |     //
//     ____) |   | |   | |\  |         ____) || |__| || |        | |     //
//    |_____/    |_|   |_| \_|        |_____/  \____/ |_|        |_|     //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

Merkulov E. V. Ⓒ  2025
*/

# README для проекта TOF-MEASURE на ESP32

## Описание проекта

Проект TOF-MEASURE представляет собой веб-приложение, работающее на микроконтроллере ESP32, которое позволяет измерять расстояние с использованием I2C-датчика TF Luna. 
Данные о расстоянии отображаются на веб-странице, которая обновляется каждые 3 секунды.

## Схема подключения

[ESP32]
   | 
   +--> [TF Luna (I2C)]
   |         |
   |         +--> SDA (GPIO 21)
   |         +--> SCL (GPIO 22)

### Подключение:

1. **SDA**: Подключите вывод SDA датчика TF Luna к GPIO 21 ESP32.
2. **SCL**: Подключите вывод SCL датчика TF Luna к GPIO 22 ESP32.
3. **Питание**: Подключите питание (VCC) и землю (GND) датчика TF Luna к соответствующим выводам ESP32.

## Необходимые компоненты

- ESP32
- Датчик TF Luna (I2C)
- Соединительные провода
- Компьютер с установленной Arduino IDE

## Установка библиотек

Перед использованием проекта убедитесь, что у вас установлены следующие библиотеки:

- **Wire**: Библиотека для работы с I2C.
- **WiFi**: Библиотека для подключения к Wi-Fi.
- **WebServer**: Библиотека для создания веб-сервера.

## Настройки Wi-Fi

В коде замените следующие строки на ваше имя Wi-Fi и пароль:

const char* ssid = "Ваше_имя_Wi-Fi";        
const char* password = "Ваш_пароль_Wi-Fi"; 

## Компиляция и загрузка

1. Откройте Arduino IDE.
2. Скопируйте и вставьте код в новый скетч.
3. Подключите ESP32 к компьютеру.
4. Выберите соответствующий порт и модель ESP32 в меню инструментов.
5. Нажмите кнопку "Загрузить" для компиляции и загрузки скетча.

## Использование

1. После загрузки скетча откройте Serial Monitor (9600 бод) в Arduino IDE для проверки состояния подключения к Wi-Fi.
2. Найдите IP-адрес вашего ESP32, который будет выведен в Serial Monitor.
3. Откройте веб-браузер и введите IP-адрес в адресной строке.
4. Вы увидите страницу с заголовком "TOF-MEASURE" и отображаемым расстоянием, которое будет обновляться каждые 3 секунды.

## Структура кода

1. **Инициализация**
   - Подключение к I2C и Wi-Fi.
   - Запуск веб-сервера.
   
2. **Основной цикл (loop)**
   - Обновление расстояния каждые 2 секунды.
   - Обработка клиентских запросов.

3. **Обработчики запросов**
   - `handleRoot()`: Отправляет HTML-страницу с текущим расстоянием.
   - `handleUpdate()`: Обновляет данные о расстоянии и отправляет их клиенту.

4. **Чтение данных**
   - `readDistance()`: Читает данные от датчика TF Luna через I2C и возвращает расстояние в сантиметрах.

## Примечания

- Убедитесь, что датчик подключен и работает корректно, чтобы избежать ошибок при считывании данных.
- В случае возникновения проблем с подключением к Wi-Fi проверьте правильность введенных SSID и пароля.

Схема программы:

[Инициализация]
     |
     v
[Основной цикл (loop)]
     |
     +--> [Инициализация]
     |         |
     |         +--> Инициализация последовательного порта
     |         +--> Инициализация I2C
     |         +--> Подключение к Wi-Fi
     |         +--> Настройка веб-сервера
     |         +--> Вывод IP-адреса в Serial Monitor
     |
     +--> [Обработка запросов от клиентов]
     |         |
     |         +--> [Проверка состояния клиента]
     |                  |
     |                  +--> Если запрос на главную страницу:
     |                  |         +--> Вызов handleRoot
     |                  |
     |                  +--> Если запрос на обновление данных:
     |                            +--> Вызов handleUpdate
     |
     +--> [Обновление данных о расстоянии]
     |         |
     |         +--> [Проверка времени обновления]
     |                  |
     |                  +--> Если прошло 2 секунды:
     |                            +--> Вызов updateDistance
     |
     +--> [Обработка данных о расстоянии]
               |
               +--> [Чтение расстояния из датчика]
               |         |
               |         +--> Вызов readDistance
               |                  |
               |                  +--> Если данные получены:
               |                  |         +--> Преобразование в метры
               |                  |         +--> Обновление lastResponse
               |                  |
               |                  +--> Если ошибка:
               |                            +--> Обновление lastResponse с ошибкой
               |
               +--> [Отправка данных на клиент]
                         |
                         +--> Если запрос на обновление:
                                   +--> Ответ клиенту с текущим расстоянием
                         |
                         +--> Если запрос на главную страницу:
                                   +--> Ответ клиенту с HTML-страницей
     |
     +--> [Команды препроцессора]
               |
               +--> #include <Wire.h>
               +--> #include <WiFi.h>
               +--> #include <WebServer.h>
     |
     +--> [Прототипы функций]
               |
               +--> void setup();
               +--> void loop();
               +--> void handleRoot();
               +--> void handleUpdate();
               +--> void updateDistance();
               +--> int readDistance();

Этапы компиляции программы можно представить в виде последовательности шагов, 
которые выполняются компилятором для преобразования исходного кода в исполняемый файл. 
Основные этапы компиляции можно разбить на следующие:

1. **Препроцессинг**:
   - Обработка директив препроцессора (`#include`, `#define`, и т.д.)
   - Включение заголовочных файлов и замена макросов.

2. **Компиляция**:
   - Преобразование исходного кода в промежуточный код (обычно в ассемблерный).
   - Проверка синтаксиса и семантики.

3. **Ассемблирование**:
   - Преобразование ассемблерного кода в машинный код (объектный файл).

4. **Линковка**:
   - Объединение объектных файлов и библиотек в один исполняемый файл.
   - Разрешение внешних ссылок и создание финального исполняемого файла.

Можно представить эти этапы в виде схемы:

[Исходный код (.cpp)]
     |
     v
[Препроцессинг]
     |
     +--> [Обработка директив препроцессора]
     |         |
     |         +--> Включение заголовочных файлов
     |         +--> Замена макросов
     |
     v
[Исходный код после препроцессинга]
     |
     v
[Компиляция]
     |
     +--> [Преобразование в промежуточный код]
     |         |
     |         +--> Проверка синтаксиса
     |         +--> Проверка семантики
     |
     v
[Промежуточный код (ассемблерный)]
     |
     v
[Ассемблирование]
     |
     +--> [Преобразование в машинный код]
     |
     v
[Объектный файл (.o)]
     |
     v
[Линковка]
     |
     +--> [Объединение объектных файлов]
     |         |
     |         +--> Разрешение внешних ссылок
     |
     v
[Исполняемый файл (.exe / .bin)]

### Подробное описание этапов:

1. **Препроцессинг**:
   - Препроцессор обрабатывает все директивы, отбрасывает комментарии и обрабатывает макросы. Например, `#include <Wire.h>` включает код из библиотеки `Wire.h`, а `#define TF_LUNA_ADDRESS 0x10` заменяет все вхождения `TF_LUNA_ADDRESS` на `0x10`.

2. **Компиляция**:
   - Компилятор принимает предварительно обработанный код и преобразует его в ассемблерный код. На этом этапе происходит анализ кода на наличие синтаксических ошибок и проверка типов.

3. **Ассемблирование**:
   - Ассемблер преобразует ассемблерный код в объектный файл, который содержит машинный код, но еще не является полным исполняемым файлом.

4. **Линковка**:
   - Линковщик объединяет все объектные файлы и библиотеки в один исполняемый файл. Он также решает, как ссылки на функции и переменные из разных файлов будут скомпонованы в финальном исполняемом файле.
